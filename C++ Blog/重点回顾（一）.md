# 重点回顾（一）

## 函数重载

### 定义

同名函数的形参列表（参数个数或类型或顺序）不同以实现几个类似功能的情况（返回值不是判断依据）

### 原理

#### 名字修饰

在编译过程中，Name Mangling会将函数、变量的名称重新改编

C语言的名字修饰规则只是在函数名字前加下划线（_），所以不能出现同名函数

C++的名字修饰规则包括函数名字，参数类型及返回值，所以可以根据不同的形参列表来构成重载，link的时候重载函数不会出现多重定义

## 引用

引用就是给已存在的变量取别名。

### 引用特性

* 引用在定义时必须初始化
* 一个变量可以有多个引用
* 引用一旦初始化，就不能再引用其他实体
* 如果引用做函数返回值时，生命周期要比函数的生命周期长
* 在语法概念上引用不占独立空间，和其引用实体共用同一块空间
* 在底层实现上实际是有空间的，因为引用是按照指针方式来实现的

### 引用和指针的区别

* 引用在定义时必须初始化，指针没有要求
* 引用一经初始化就不能在引用其他实体，而指针可以在任何时候指向任何一个同类型实体
* 没有NULL引用，但有NULL指针
* sizeof求大小时，引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）
* 引用自加即所引用的实体+1,指针自加即向后偏移一个类型的大小
* 有多级指针，但没有多级引用
* 访问实体方式不同，指针需要显式解引用，引用编译器自己处理
* 引用比指针使用起来相对更安全

## 内联函数

以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，提升程序运行的效率

### 特性

* inline是一种以空间换时间的做法，省去调用函数的开销，所以内部内容较多的或者有递归、循环的函数不适宜作为内联函数
* inline对于编译器而言只是一个建议，编译器会自动优化
* inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开就没有函数地址了，链接找不到

## 宏的优缺点

### 优点：

* 增强代码的复用性
* 提高性能

### 缺点：

* 不方便调试宏（预编译阶段进行了替换）
* 导致代码可读性差，可维护性差，容易误用
* 没有类型安全的检查

### C++有哪些技术替代宏

1.常量定义  const

2.函数定义 inline

## auto关键字

auto作为指示符来指示编译器，auto声明的变量由编译器在编译时自动推导

### 注意：

* auto定义变量时必须对其进行初始化，在编译阶段需要根据初始化表达式来推到实际类型，auto不是一种类型的声明，而是一个类型声明时的”占位符“，编译器在编译时会将其替换为实际的类型
* auto声明引用类型必须加&
* 同一行定义多个变量，根据第一个推导类型，用推导出来的类型定义后面的变量

#### auto不能推导的情景：

* 函数的参数（重载冲突）
* 声明数组（空间分配不确定）
* 类的非静态成员变量
* 模板参数

## C++中struct和class的区别

##### struct的成员默认访问方式是public，class是private

## 面向对象的三大特性：封装、继承、多态

### 封装：

##### 将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外开放接口来和对象进行交互。

### 继承：

##### 在保持原有类特性的基础上进行扩展，增加功能，使代码可以复用的最重要手段。类设计层次的复用

### 多态：

##### 完成某个行为，不同的对象会产生出不同的状态。

## 类的大小

##### 一个类的大小，实际就是该类中“成员变量”之和，也要进行内存对齐，空类为一个字节，用以维一标识这个类

## 结构体内存对齐规则

1. 第一个成员在与结构体偏移量为0的地址处。

2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处

   对齐数=编译器默认的一个对齐数与该成员大小的较小值

   VS中默认的对齐数为8，gcc中的对齐数为4

3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍

4. 如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

   