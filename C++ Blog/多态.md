##### 多态

### 1.多态的概念

> ##### 当不同的对象去完成某个行为时会产生出不同的状态
>
> ##### 多态看实际指向的对象，调用对象对应类型的代码
>
> ##### 非多态看类型，调用对应类型的代码

### 2.多态定义及实现

##### 多态定义的构成条件

> * 继承
> * 调用函数的对象必须是指针或者引用
> * 被调用的函数必须是虚函数，且完成了虚函数的重写

##### 什么是虚函数？

> 虚函数就是在类的成员函数的前面加virtual关键字
>
> ```
> class Person
> {
> public：
> 	virtual void BuyTicket(){cout<<"买票-全价"<<endl;}
> };
> ```

##### 虚函数的重写（虚函数的覆盖）

> 派生类中有一个跟基类的完全相同虚函数，我们就称子类的虚函数重写了基类的虚函数。完全相同是指：函数名、参数、返回值都相同。
>
> ```
> class Person
> {
> public:
> 	virtual void BuyTicket(){cout<<"买票-全价"<<endl；}
> };
> class Student : public Person
> {
> public:
> 	virtual void BuyTicket(){cout<<"买票-半价"<<endl;}
> };
> void Func(Person& p)
> {
>     p.BuyTicket();
> }
> 
> int main()
> {
>     Person ps;
>     Student st;
>     Func(ps);
>     Func(st);
>     return 0;
> }
> ```
>

##### 函数重写的例外：协变

> 重写的虚函数的返回值不同，但必须分别是基类指针和派生类指针或者基类引用和派生类引用（**不单指当前基类和派生类）**
>
> ```
> class A{};
> 
> class B : public A{};
> 
> class Person
> {
> public:
> 	virtual A* f(){return new A;}
> };
> 
> class Student : public Person
> {
> public:
> 	virtual B* f(){return new B;}
> };
> ```

##### 不规范的重写行为：

> 在派生类中重写的成员函数可以不加virtual关键字，也是构成重写的

##### 析构函数的重写问题

> 基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相 同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor，这也说明的基类的析构函数最好写成虚函数。

### 3.重载、覆盖（重写）、隐藏（重定义）的对比

> * 重载
>   - 两个函数在同一作用域
>   - 函数名相同，参数个数/类型/顺序不同
> * 重写（覆盖）
>   * 两个函数分别在基类和派生类的作用域
>   * 函数名、参数、返回值都必须相同（协变除外）
>   * 两个函数必须是虚函数
> * 重定义（隐藏）
>   * 两个函数分别在基类和派生类的作用域
>   * 函数名相同
>   * 两个基类和派生类的同名函数不构成重写就是重定义

### 4.抽象类

> 在虚函数的后面加上=0，则这个函数为纯虚函数
>
> 包括纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象，派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承
>
> ```
> class Car
> {
> public:
> 	virtual void Drive() = 0;
> };
> 
> class Benz : public Car
> {
> public:
> 	virtual void Drive()
> 	{
>         cout<<"Benz-舒适"<<endl;
> 	}
> };
> 
> class BMW : pulic Car
> {
> public:
> 	virtual void Drive()
> 	{
>         cout<<"BMW-操控"<<endl;
> 	}
> };
> 
> void Test()
> {
>     Car* pBenz = new Benz;
>     pBenz->Drive();
>     
>     Car* pBMW = new BMW;
>     pBMw->Drive();
> }
> ```

##### C++11 override和final

> C++11用override和final来修饰虚函数
>
> 实际中应多使用纯虚函数+override的方式来强制重写虚函数，因为虚函数的意义就是实现多态，如果没有重写，虚函数就没有意义
>
> ```
> //1.final修饰基类的虚函数不能被派生类重写
> class Car
> {
> public：
> 	virtual void Derive() final {}	
> };
> 
> class Benz : public Car
> {
> public:
> 	virtual void Drive(){cout<<"Benz-舒适"<<endl;}
> }；
> ```
>
> ```
> //2.override修饰派生类的虚函数强制完成重写，如果没有重写会编译出错
> class Car
> {
> public：
> 	virtual void Derive() {}	
> };
> 
> class Benz : public Car
> {
> public:
> 	virtual void Drive() override {cout<<"Benz-舒适"<<endl;}
> }；
> ```
>
> 

### 5.多态的原理

##### 虚函数表

> 1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在这个部分，另一部分是自己的成员。
> 2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。重写是语法的叫法，覆盖是原理层的叫法。 
> 3. .另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。
> 4. 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。
> 5. 总结一下派生类的虚表生成：a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后
> 6. 虚函数存在哪的？虚表存在哪的？ 答：虚函数存在虚表，虚表存在对象中。注意上面的回答的错的。但是很多童鞋都是这样深以为然的。注意虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。那么虚表存在哪的呢？实际我们去验证一下会发现vs下是存在代码段的

##### 动态绑定与静态绑定

> * 静态绑定又称为前期绑定（早绑定），在程序编译期间确定了程序的行为，也称为静态多套。比如：函数重载
> * 动态绑定又称后期绑定（晚绑定），是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态

### 6.多态常见面试题

> 1.什么是多态

> * 当不同的对象去完成某个行为时会产生出不同的状态
> * 多态看实际指向的对象，调用对象对应类型的代码
> * 非多态看类型，调用对应类型的代码
>
> 2.什么是重载、重写（覆盖）、重定义（隐藏）
>
> * 重载
>   * 两个函数在同一个作用域
>   * 函数名相同，参数不同
> * 重写（覆盖）
>   * 两个函数分别在基类和派生类的作用域
>   * 函数名/参数/返回值都必须相同（协变除外）
>   * 两个函数必须是虚函数
> * 重定义（隐藏）
>   * 两个函数分别在基类和派生类的作用域
>   * 函数名相同
>   * 两个基类和派生类的同名函数不构成重写就是重定义
>
> 3.多态的实现原理
>
> * 通过虚函数表指针_vfptr来实现多态
> * 一个含有虚函数的类中都至少有一个虚函数表指针
> * 虚函数表指针指向一个虚表
> * 虚表存放当前类的虚函数指针，本质为指针数组，虚表本身在代码段（VS下）
> * 子类继承父类的虚表，对于子类重写的函数，覆盖掉父类对应的虚函数，虚表只存放虚函数的地址，不存放普通函数的地址
> * 单继承需表结构：首先存放父类虚函数地址，子类定义的虚函数，对应的地址按顺序依次存放在虚表末尾
> * 多继承：虚表的个数和直接父类的个数一致，子类定义的虚函数，对应的地址按顺序依次存放在第一个直接父类的虚表末尾

> 4.inline函数可以是虚函数吗
>
> * 不能，因为inline函数没有地址，无法把地址放到虚函数表中
>
> 5.静态成员可以是虚函数吗
>
> * 不能，因为静态成员函数没有this指针，使用类型::成员函数的调用方式无法访问虚函数表，所以静态成员函数无法放进虚函数表
>
> 6.构造函数可以是虚函数吗
>
> * 不能，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的
>
> 7.析构函数可以是虚函数吗，什么场景下析构函数是虚函数
>
> * 可以，并且最好把基类的析构函数定义成虚函数
> * 编译器底层会把基类和派生类的析构函数都命名为_destruction
>
> 8.对象访问普通函数快还是虚函数更快
>
> * 首先如果是普通对象，是一样快的。
> * 如果是指针对象或者是引用对象，则调用的普通函数快，因为构成多态，运行时调用虚函数需要到虚表中去查找
>
> 9.虚函数表实在什么阶段生成的，存在哪的
>
> * 虚函数是在编译阶段就生成的，一般情况下存在于代码段（常量区）
>
> 10.C++菱形继承的问题，虚继承的原理
>
> 11.什么是抽象类，抽象类的作用