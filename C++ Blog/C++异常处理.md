# C++异常处理

### C语言传统的处理错误的方式：

> 1. 终止程序，如assert，缺陷：用户难以接受。如发生内存错误，除零错误时就会终止程序
> 2. 返回错误码，缺陷：错误提示不够明确直接，需要程序员自己去查找对应的错误。如系统的很多库的接口函数都是通过把错误码放到errno中，表示错误
> 3. C标准库中setjmp和longjmp组合。
>
> 实际中C语言基本都是使用返回错误码的方式处理错误，部分情况下使用终止程序处理非常严重的错误

### C++异常概念

> 异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的直接或间接的调用者处理这个错误
>
> * throw：当问题出现时，程序会抛出一个异常。这是通过throw关键字来完成的
> * catch：在想要处理问题的地方，通过异常处理程序捕获异常。catch关键字用于捕获异常，可以有多个catch进行捕获
> * try：try块中的代码标识将被激活的特定异常，他后面通常跟着一个或多个catch块
>
> 如果有一个块抛出一个异常，捕获异常的方法会使用try和catch关键字。try块中放置可能抛出异常的代码，try块中的代码被称为保护代码。使用try/catch的语法如下所示：
>
> ```
> try
> {
>     //保护的标识代码
> }catch(ExceptionName e1）
> {
>     //catch块
> }catch(ExceptionName e2)
> {
>     //catch块
> }catch(ExceptionName eN)
> {
>     //catch块
> }
> ```

### 异常的使用

##### 异常的抛出和匹配原则

> 1. 异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。
> 2. 被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个
> 3. 抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会被catch以后销毁（这里的处理类似于函数的传值返回）
> 4. catch（...）可以捕获任意类型的异常，但不知道异常错误是什么
> 5. 实际中抛出和捕获的匹配原则有个例外，并不都是类型完全匹配，可以抛出派生类对象，使用基类捕获，实际中非常实用

##### 在函数调用链中异常栈展开匹配原则

> 1. 首先检查throw本身是否在try块内部，如果是再查找匹配的catch语句。如果有匹配的，则跳到catch的地方进行处理
> 2. 没有匹配的catch则退出当前函数栈，继续在调用函数的栈中进行查找匹配的catch
> 3. 如果到达main函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的catch子句的过程称为栈展开。所以实际中最后都要加一个catch(...)捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止
> 4. 找到匹配的catch子句并处理以后，会继续沿着catch子句后面继续执行

> ```
> double Division(int a, int b)
> {
> 	//当b==0时抛出异常
> 	if(b == 0)
> 		throw "Division by zero condition!";
> 	else
> 		return ((double)a / (double)b);
> }
> 
> void Func()
> {
>     int len, time;
>     cin>>len>>time;
>     cout << Division(len, time) << endl;
> }
> 
> int main()
> {
>     try{
>         Func();
>     }
>     catch(const char* errmsg){
>         cout<<errmsg<<endl;
>     }
>     catch(...){
>         cout<<"unknow exception"<<endl;
>     }
>     return 0;
> }
> 
> ```

##### 异常的重新抛出

> 有可能单个的catch不能完全处理一个异常，在进行一些校正处理以后，希望再交给更外层的调用链函数来处理，catch则可以通过重新抛出将异常传递给更上层的函数进行处理

##### 异常安全

> * 构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化
> * 析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄露（内存泄漏，句柄未关闭等）
> * C++中异常经常会导致资源泄露的问题，比如在new和delete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出异常导致死锁，C++经常使用RAII来解决以上问题

##### 异常规范

> 1. 异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些。可以在函数的后面接throw（类型），列出这个函数可能抛掷的所有异常类型
> 2. 函数的后面接throw()，表示函数不抛异常
> 3. 若无异常接口声明，则此函数可以抛掷任何类型的异常

### 自定义异常体系

> 实际中都会定义一套继承的异常规范体系，这样大家抛出的都是继承的派生类对象，捕获一个基类就可以了

### C++标准库的异常体系

> ![1558321600098](C:\Users\xdd\AppData\Local\Temp\1558321600098.png)
>
> ![1558321665720](C:\Users\xdd\AppData\Local\Temp\1558321665720.png)

> 实际中我们可以去继承exception类实现自己的异常类

### 异常的优缺点

> C++异常的优点：
>
> * 异常对象定义好了，相比错误码的方式可以清晰准确的展示出错误的各种信息，甚至可以包含堆栈调用的信息，这样可以帮助更好的定位程序的bug
> * 返回错误码的传统方式有个很大的问题就是，在函数调用链中，深层的函数返回了错误，那么我们得层层返回错误，最外层才能拿到错误
> * 很多的第三方库都包含异常，比如boost、gtest、gmock等等常用的库，使用它们也需要使用异常
> * 很多测试框架都使用异常，这样能更好的使用单元测试等进行白盒的测试
> * 部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理，比如T& operator这样的函数，如果pos越界了只能使用异常或者终止程序处理，没办法通过返回值表示错误
>
> C++异常的缺点：
>
> * 异常会导致程序的执行流乱跳，并且非常的混乱，并且是运行时出错抛异常就会乱跳。这会导致我们跟踪调试时以及分析程序时，比较困难。
>
> * 异常会有一些性能的开销，现代硬件速度很快，这个影响基本忽略不计
>
> * C++没有垃圾回收机制，资源需要自己管理。有了异常非常容易导致内存泄漏、死锁等异常安全问题。可通过使用RAII来处理资源的管理问题。学习成本较高
>
> * C++标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱
>
> * 异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：
>
>   * 抛出异常类型都继承自一个基类
>
>   * 函数是否抛异常、抛什么异常，都使用func()
>
>     throw();的方式规范化