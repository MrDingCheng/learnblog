### C++中的继承

##### 1.继承的概念及定义

**1.1继承的概念**

> 继承是面向对象程序设计使代码复用的最重要的手段，它允许在保持原有类特性的基础上进行扩展，增加功能，产生派生类。
> 继承是类设计层次的复用。
> 继承呈现了面向对象程序设计的层次结构。

> ```
> class Person
> {
> public:
> 	void Print()
> 	{
>         cout<<"name:"<<_name<<endl;
>         cout<"age:"<<_age<<endl;
> 	}
> protected:
>   	string _name = "Peter";
>   	int _age = 18;
> };
> //继承后父类的Person的成员都会变成子类的一部分。Student类和Teacher类复用了Person的成员
> class Student : public Person
> {
> protected:
> 	int _stuid;
> }；
> class Teacher : public Person
> {
> protected:
> 	int _jobid;
> }
> int main()
> {
>     Student s;
>     Teacher t;
>     s.Print();
>     t.Print();
>     return 0;
> }
> 
> ```

##### 1.2 继承定义

> 1.2.1定义格式
>
>   class 派生类名 ： 继承方式  基类
>
> 1.2.2继承关系和访问限定符
>
>  	public继承/访问
>
> ​	protected继承/访问
>
> ​	private继承/访问
>
> 1.2.3继承基类成员访问方式的变化
>
> ​	1.基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的private成员还是被继承到了派生类对象中，但hi语法上限制派生类对象无论类内还是类外都不可去访问它。
>
> ​	2.如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。
>
> ​	3.基类的其他成员（即除了private）在子类的访问方式 = Min(成员在基类的访问限定符，继承方式)，且public>protected>private。
>
> ​	4.使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过最好显式的写出继承方式。
>
> ​	5.实际运用中一般使用的都是public继承，几乎很少使用protected/private继承，也不提倡使用，因为protected/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。

##### 2.基类和派生类对象赋值转换

> * 派生类对象可以赋值给基类对象/基类的指针/基类的引用。发生切片操作，把派生类中父亲那部分切来赋值过去
>
> * 基类对象不能赋值给派生类对象
>
> * 基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。否则会发生越界问题。
>
>   ```
>   class Person
>   {
>   protected:
>   	string _name;
>   	string _sex;
>   	int _age;
>   };
>   class Student : public Person
>   {
>   public:
>   	int _NO;
>   };
>   void Test()
>   {
>       Student sobj;
>       //1.子类对象可以赋值给父亲对象/指针/引用
>       Person pobj = sobj;
>       Person* pp = &sobj;
>       Person& rp = sobj;
>       //2.基类对象不能赋值给派生类对象
>       //sobj = pobj;
>       //3.基类的指针可以通过强制类型转换赋值给派生类的指针
>       pp = &sobj;
>       Student* ps1 = (Student*)pp;//基类指针原来就指向派生类对象
>       ps1->_NO = 10;
>       
>       pp = &pobj;
>       Student* ps2 = (Student*)pp;
>       ps2->_NO = 10;//越界访问
>   }
>   ```

##### 3.继承中的作用域

> 1.在继承体系中基类和派生类都有独立的作用域。
>
> 2.子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏。也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显式访问）
>
> 3.只要派生类和基类函数名相同就构成成员函数隐藏。
>
> 4.实际中在继承体系里面最好不要定义同名的成员

##### 4.派生类的默认成员函数

> 1.派生类的构造函数必须调用基类的构造函数初始化基类的那边一部分成员
>
> * 如果基类有默认的构造函数，编译器默认调用
> * 如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显式调用。
>
> 2.派生类的拷贝函数必须调用基类的拷贝构造完成基类的拷贝初始化
>
> * 如果子类没有拷贝构造函数，编译器自己生成一个主动调用父类的拷贝构造的子类拷贝构造函数
>
> * 如果子类定义了自己的拷贝构造函数，而且没有显式调用父类的拷贝构造，则会默认调用基类的**默认构造函数**
>
> 3.派生类的operator=必须要调用基类的operator=完成基类的复制
>
> * 如果子类没有定义operator=，编译器默认生成的子类赋值运算符重载函数，默认调用父类的赋值运算符重载
> * 如果子类定义了operator=，则不会调用父类的赋值运算符重载，所以可以直接在子类的赋值运算符重载函数中直接给父类的成员变量赋值
> * 建议直接在子类中赋值运算符重载函数中调用父类运算符重载函数，**调用时注意同名函数隐藏问题**
>
> 4.派生类的析构函数
>
> * 子类析构函数在底层会和基类的析构函数构成同名（destructor）函数隐藏
> * 编译器会自动调用基类的析构函数，不允许显式调用基类的析构函数，因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序
>
> 5.派生类对象初始化先调用基类构造再调用派生类构造
>
> 6.派生类对象析构清理先调用派生类析构再调基类的析构

##### 5.继承与友元

> 友元关系不能继承

##### 6.继承与静态成员

> 积累定义了static静态成员，则整个继承体系里面只有一个这样的成员。

##### 7.菱形继承及菱形虚拟继承

> 单继承：一个子类只有一个直接父类
>
> 多继承：一个子类有两个或以上直接父类
>
> 菱形继承：多继承的一种特殊情况，类A派生出类B，C，类B，C派生出类D，在类D中就存在多份A中继承下来的成员，即数据冗余，在D类使用中会产生二义性问题。
>
> 虚拟继承可以解决菱形继承的二义性和数据冗余问题。
>
> 虚拟继承中，通过B和C的两个虚基表指针，指向的虚基表，虚基表中存的相对与两个虚基表指针的地址的相对偏移量，通过偏移量可以找到公有的继承于A的成员。

##### 8.继承和组合

> * public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。
> * 组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。
> * 优先使用对象组合，而不是类继承 。
> * 继承允许你根据基类类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见。继承一定程度破坏了基类的封装，基类的改变，对派生类类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。
> * 对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。
> * 实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。