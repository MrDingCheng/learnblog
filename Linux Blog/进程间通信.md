# 进程间通信

### 进程间通信的原因

> 进程之间具有独立性，每个进程有自己的虚拟地址空间，进程A并不知道进程B的虚拟地址空间中的数据内容
>
> 进程间通信需要”介质“，两个进程都能访问到的公共资源（如文件）
>
> 借助文件就可以完成进程间通信。最简单的进程间通信方法
>
> 操作系统专门提供的进程间通信方式
>
> * 匿名管道 |
> * 命名管道
> * 消息队列
> * 共享内存
> * 信号量
>
> 最重要的进程间通信方式：网络

### 进程间通信目的

> * 数据传输：一个进程需要将它的数据发送给另一进程
> * 资源共享：多个进程之间共享同样的资源
> * 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）
> * 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变

### 进程间通信发展

> * 管道
> * System V进程间通信
> * POSIX进程间通信

### 进程间通信分类

管道

> * 匿名管道pipe
> * 命名管道 | 
>   * 前一个进程的输出作为后一个进程的输入

System V IPC

> * System V 消息队列
> * System V 共享内存
> * System V 信号量

POSIX IPC

> * 消息队列
> * 共享内存
> * 信号量
> * 互斥量
> * 条件变量
> * 读写锁

### 管道

> * 管道是Unix中最古老的进程间通信的形式，就是内核中的一块内存（构成了一个队列），使用一对文件描述符来进行访问这个内存。读文件描述符就是从队列中取数据；写文件描述符就是往队列中插入数据
> * 我们把从一个进程连接到另一个进程的一个数据流成为一个”管道“

### 匿名管道

> ```
> #include <unistd.h>
> 功能：创建一无名管道
> 原型
> int pipe(int fd[2]);
> 参数
> fd：文件描述符数组，其中fd[0]表示读端，fd[1]表示写端
> 返回值：成功返回0，失败返回错误代码
> ```

### 用fork来共享管道原理

> 创建子进程，子进程会拷贝父进程的文件描述符表
>
> 父进程写管道的时候，子进程就能从管道中读取出数据

> 管道中的数据一旦被读了之后，就相当于出队列了
>
> 假设有多个进程同时去尝试读，只有一个进程能读到数据
>
> 管道内置了“**同步互斥机制**”不会出现两个管道一人读一半数据的情况
>
> * 多个进程同时去读写管道，数据不会发生错误
> * 如果管道为空，尝试读，就会在read函数处阻塞
> * 如果管道满了，尝试写，就会在write函数出阻塞

### 管道读写规则

> * 当没有数据可读时
>   * O_NONBLOCK disable：read调用阻塞，即进程暂停执行，一直等到有数据来到为止
>   * O_NONBLOCK enable：read调用返回-1，errno值为EAGAIN
> * 当管道满的时候
>   * O_NONBLOCK disable：write调用阻塞，直到有进程读走数据
>   * O_NONBLOCK enable：调用返回-1，errno的值为EAGAIN
> * 如果所有管道写端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE，进而可能导致write进程退出
> * 当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性
> * 当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性

### 管道特点

> * 只能用于具有共同祖先的进程（具有亲缘关系的进程）之间进行通信；通常，一个通道由一个进程创建，然后给该进程调用fork，此后父、子进程之间就可应用该管道
> * 管道提供流式服务（面向字节流）
> * 一般而言，进程退出，管道释放，所以管道的生命周期随进程
> * 一般而言，内核会对管道操作进行同步与互斥
> * 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道

### 命名管道

> * 管道应用的一个限制就是只能在具有共同祖先（具有亲缘关系）的进程间通信
> * 如果我们想在不相关的进程之间交换数据，可以使用FIFO文件来做这项工作，它经常被称为命名管道
> * 命名管道是一种特殊类型的文件

### 创建一个命名管道

> * 命名管道可以从命令行上创建，命令行方法是使用下面这个命令：

```
$ mkfifo filename
```

> * 命名管道也可以从程序里创建，相关函数有：

> 所有的读端关闭，写端read返回0
>
> 命名管道的生命周期是跟随进程的，myfifo这个文件仅仅是一个入口，管道的本体仍然是内核中的一个内存。生命周期围绕内核中的内存来说的。

### system V共享

> 共享内存区是最快的IPC形式，一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不在涉及到内核，也就是说进程不再通过执行进入内核的系统调用来传递彼此的数据

##### 共享内存的使用方式

> 1. 在内核中先创建出共享内存对象（shmget）
> 2. 将进程附加到这个共享内存对象上（shmat->attach）
> 3. 可以直接读写这个共享内存对象

##### 共享内存函数

shmget函数

```
功能：用来创建共享内存
原型
	void shmget(key_t key, size_t size, int shmflg);
参数
	key：共享内存段名字（通过ftok（char* pathname,key_t key）来获取，pathname必须是存在的）
	size：共享内存大小
	shmflg：由九个权限标志构成，它们的用法和创建文件时使用的mode模式标志是一样的
返回值：成功返回一个非负整数，即该共享内存段的标识码；失败返回-1
ipcs -m 查看系统中的共享内存
共享内存的声明周期随内核。共享内存会一直存在，直到主动释放，或者重启内核
```

shmat函数

```
功能：将共享内存段连接到进程地址空间
原型
	void *shmat(int shmid,const void *shmaddr, int shmflg);
参数
	shmit：共享内存标识
	shmaddr：指定连接的地址
	 	shamaddr为NULL,核心自动选择一个地址
	 	shmaddr不为NULL且shmflg无SHM_RND标记，则以shmaddr为连接地址
	 	shmaddr不为NULL且shmflg设置了SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍	
	 	shmaddr=SHM_RDONLY，表示连接操作用来只读共享内存
	shmflg：它的两个可能取值是SHM_RND和SHM_RDONLY
返回值：成功返回一个指针，指向共享内存的第一个字节；失败返回-1
```

shmdt函数

```
功能：将共享内存段与当前进程脱离
	int shmdt(const void *shmaddr)
参数
	shmaddr:由shmat所返回的指针
返回值：成功返回0；失败返回-1
```

### 消息队列

> 也是一个队列，每个元素都带有一个类型出队列的时候，是按照指定类型来先进先出的

### system V消息队列

> * 消息队列提供了一个从一个进程向另外一个进程发送一块数据的方法
> * 每个数据块都被认为是有一个类型，接收者进程接受的数据块可以有不同的类型值
> * 特性方面
> * IPC资源必须删除，否则不会自动清除，除非重启，所以system V IPC资源的生命周期随内核

### system V信号量

> 信号量是一个计数器，负责进行进程间的同步和互斥，这个计数器描述了可用资源的个数
>
> 每次有进程申请一个可用资源的时候，计数器-1      p操作
>
> 每次有进程释放一个可用资源的时候，计数器+2     v操作
>
> 如果计数器已经是0了，这时再有进程申请资源
>
> 1.进程会挂起等待
>
> 2.进程会放弃申请资源