# 多线程

### Linux线程概念

##### 什么是线程

> * 在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”
> * 一切进程至少都有一个执行线程
> * 线程在进程内部运行，本质是在进程地址空间内运行
> * 在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更加轻量化
> * 通过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了流程执行流
> * 线程是运行在进程之中的，进程负责资源的管理（管理内存，管理打开的文件），线程负责调度和执行（和进程类型，也是抢占式的调度）
> * Linux也把线程叫做轻量级进程（LWP）

##### 线程的优点

> * 创建/销毁一个新线程的代价要比创建/销毁一个新进程小得多
> * 每次创建一个新的进程，会分配新的虚拟地址空间，每次创建一个新的线程，线程共用原来的虚拟地址空间
> * 与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多
> * 线程占用的资源要比进程少很多
> * 能充分利用多处理器的可并行数量
> * 在等待慢速I/O操作结束的同时，程序可执行其他的计算任务
> * 计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现
> * I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作

##### 线程的缺点

> * 性能损失
>   * 一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享同一个处理器。如果计算密集型线程数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变
> * 健壮性降低
>   * 一个线程异常终止会导致进程异常终止
> * 编程/调试难度提高
>   * 对线程的可靠性要求更高
>   * 线程安全问题

##### 多线程/多进程的应用场景

> * CPU（计算）密集型
> * I/O密集型
>   * 通过网络进行输入输出
>   * 响应UI界面（界面显示和数据计算要多线程完成，防止由于计算太久导致界面卡死）

##### 线程之间共用的资源

> * 虚拟地址空间
> * 文件描述符表
> * 等等

##### 线程之间不共用的资源

> * 栈（函数调用栈，局部变量等）
> * 上下文信息（寄存器信息）
> * errno（每个线程有自己的错误码）
>   * thread local

##### 线程问题

> 线程不是越多越好，达到一定数目的时候效率就没法提升了
>
> 线程如果多了，多个线程尝试访问同一个资源，就会冲突（互斥解决）
>
> 某个线程可能一直得不到执行的机会，线程饥饿（同步）
>
> 如果某个进程异常终止，整个进程都异常终止

### 线程控制

##### POSIX线程库

> * 与线程有关的函数构成了一个完整的系列，绝大多数的名字都是以"pthread_"开头的
> * 要使用这些函数库，要引入头文件<pthread.h>,pthread中的p代表posix
> * 连接这些线程函数库时要使用编译器命令的"-lpthread"选项
>   * gcc的-l表示链接一个库，直接写库名，不用包含前缀lib或后缀.so
>
> C++11/Java/Python...各种语言都内置了线程库

##### 创建线程

**ps -eLf 查看所有的线程信息(LWP表示线程ID),站在内核角度给PCB加的编码**

**pthread_self得到的线程id是站在posix线程库的角度**

**pstack PID查看指定进程中的线程信息**

**gdb attach PID**

**	info thread查看线程**

**	thread n切换到n号线程**

**	bt查看当前线程的调用栈**

```
功能：创建一个新的线程
原型
	int pthread_create(pthread_t *thread,const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);
参数
	thread：返回线程ID
	attr：设置线程的属性，attr为NULL表示使用默认属性
	start_routine:是个函数地址，线程启动后要执行的函数，相当于新线程的入口函数
	arg：传给线程启动函数的参数
返回值：成功返回0；失败返回错误码
```

错误检查：

> * 传统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误
> * pthreads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回

**线程是抢占式执行的，当前哪个线程去执行，哪个线程去休眠，这件事件都不是程序员能决定的，全靠操作系统来决定**

**这就是多线程编程中的“万恶之源”**

##### 终止线程

> * 让线程入口函数执行结束（最主要使用的结束方式）
> * pthread_exit 让线程终止自己，pthread_exit的参数是一个void*表示线程结束的返回结果（很少用到）
> * 一个线程可以调用pthread_cancel终止同一进程中的另一个线程，参数为LWP,虽然有延迟处理，但还是有可能会导致另一个线程的事务中断，（不太推荐使用）

##### 等待进程

> 目的和进程等待类似，防止出现类似与僵尸进程的内存泄露的情况,其实是为了等待对应线程结束后再继续执行代码，保持代码运行逻辑性
>
> * pthread_join
>
> ```
> 功能：等待指定线程结束
>  int pthread_joid(pthread_t thread, void **value_ptr);
>  参数
>  	thread：线程ID
>  	value_ptr：指向一个指针，或者指向线程的返回值
> 返回值：成功返回0，失败返回错误码
> ```

##### 线程分离

> 类似于进程中的 忽略SIGCHLD信号,线程被分离后，就不需要pthread_join来显式回收了
>
> * pthread_detach
>
> * ```
>   pthread_detach(pthread_t thread)//对其他线程分离
>   pthread_detach(pthread_self())//对自己分离
>   ```

到底搞几个线程合适？线程数目和工作的任务类型有关，究竟多少个合适，要通过测试来判定