# Linux概念

### 冯诺依曼体系结构

##### 计算机的硬件组件

> * 输入单元：包括键盘、鼠标、扫描仪、写板等
> * 中央处理器（CPU）：含有运算器和控制器等
> * 输出单元：显示器、打印机等
> * 存储器（内存、外存）
> * * 内存：空间比较小，访问速度快，成本较高，断电之后数据丢失；
>   * 外存：空间比较大，访问速度慢，成本较低，断电之后数据仍然存在

> ##### 寄存器：CPU上的存数据的组件
>

### 操作系统

> ##### 搞管理的软件
>
> * 管理软件设备
> * 管理软件资源

### 进程

> 概念：程序的一个执行实例，正在执行的程序

> Linux 按下ps或者top显示进程
>
> 使用ps aux | less对查看结果进行翻页和其他操作
>
> 使用ps aux |grep 进程名 查看匹配的进程
>
> PID:进程的身份标识符

进程和可执行程序文件没啥关联，删除可执行程序文件，进程依然存在

### 进程的管理（操作系统内核负责）

> ##### 描述进程（**PCB**进程控制块-->就是一个结构体（task_struct））
>
> * task_struct是一个很大的结构体，包含很多内容（进程标识符（pid）、内存指针（告诉进程代码/数据都在内存的哪个部分）、进程状态、其他），一个进程对应一个task_struct
>
> 组织进程
>
> * 通过双向链表进行组织，每个节点就是一个task_struct

### 进程的调度

> 让少量的CPU能够满足大量的进程同时执行的需求

> 并行：两个CPU分别执行两个进程
>
> 并发：一个CPU“同时”（快速切换）两个进程

##### 进程的状态

> * R 就绪状态，进程在就绪队列中，就会处于这个状态，要么在运行中，要么在运行队列里
> * S 睡眠状态，意味着进程在等待事件完成，即暂时轮不到
> * D 磁盘休眠状态/不可中断睡眠状态，密集的进行IO操作的时候最常见（吐coredump）
> * T 停止状态
> * t 跟踪trace
> * X 死亡状态，进程已经结束，只是在Linux源码中存在，真实是看不到的
> * Z 僵尸进程 和父子进程有关系

##### 用代码来创建子进程

> ##### fork（）
>
> * 返回值：一次调用有两个返回值。
>   * 父进程返回子进程的pid
>   * 子进程返回0
>   * 如果失败返回-1
>     * 内存不够
>     * 进程太多，达到上限
>   * 通常父子进程要完成不同的逻辑，通过fork（）的返回值来区分父子进程

> * 执行过程：父子进程都是紧接着fork继续执行
> * 父子进程先后顺序不确定，取决于操作系统的调度器

##### 僵尸进程

> 为了解决子进程向父进程汇报工作的问题而引入

> * 成因：子进程结束之后，父进程没有回收子进程的资源
> * 危害：内存泄漏
> * 处理：
>   * 直接kill僵尸进程是kill不掉的，可以kill僵尸进程的父进程（临时手段）
>   * 更科学的处理：进程等待（进程控制章节再详细介绍）

##### 孤儿进程

> 不是一种进程的状态，指的是父进程先结束了，但子进程还在，子进程的父亲就变成了1号进程（init）

> 为什么kill父进程僵尸进程就没了？当kill掉父进程之后，子进程就成为了孤儿进程，孤儿进程会被1号进程收养，从而释放资源
>
> ```
> #include <stdio.h>
> #include <unistd.h>
> #include <stdlib.h>
>  
> int main() 
> {
> 	pid_t id = fork();
>     if(id < 0)
>     {
>     	perror("fork"); 
>        	return 1;
>     }
>     else if(id == 0)
>     {//child
>     	printf("I am child, pid : %d\n", getpid());
>     	sleep(10);
>     }
>     else
>     {//parent
>     	printf("I am parent, pid: %d\n", getpid());
>     	sleep(3);
>    	 	exit(0);
>     }
>     return 0;
> }
> ```

##### 优先级

> 一个表示这个进程是先被调度执行还是后被调度执行的数字
>
> PR   数字越小，优先级越高
>
> NI（nice）优先级修正值。
>
> PR+NI=>最终PR
>
> 通过指令可以调整nice,宏观上往往看不出效果

##### 上下文（寄存器）

> CPU可能有几十个寄存器
>
> * PC指针（寄存器）：记载接下来要进行的逻辑

> 保存上下文，就是CPU寄存器的内容保存到内存中
>
> 恢复上下文，内存中的寄存器值恢复到CPU中

##### 记账信息

> 每个进程已经在CPU上执行了多久统计时间

### 环境变量

> 环境变量是一个键值对结构。键：变量名，值：变量内容
>
> env查看Linux环境变量
>
>  env ${环境变量名}查看环境变量内容
>
> 修改环境变量内容：export 环境变量名=$环境变量名：路径 
>
> * 对于PATH的修改一般只是进行追加，不会把原来的内容去掉
> * 可以通过重启终端来恢复PATH
> * 在~/.bashrc中修改PATH，重启终端不会恢复PATH，让环境变量持久生效
>
> PATH：shell中敲下的指令，去哪些目录中去查找相应的可执行程序

> echo $HOME 查看家目录
>
> echo $SHELL 查看当前shell

> ```
> //main函数的三种形式
> //env是环境变量，也是一个字符串数组
> //argc描述命令行的参数个数，argv是命令行参数
> int main(int argc, char* argv[],char* env[])
> {
> 	(void) argc;//告诉编译器，定义了的argc不用
> 	(void) argv;
> 	for(int i = 0;env[i]!=NULL;++i)
> 	{
>         printf("%s\n",env[i]);
> 	}
> 	return 0;
> }
> ```

### 程序空间回顾

> * 栈（从高地址向低地址增长）在Centos7上默认为8M,但可以通过ulimit -a修改栈的大小
>   * 局部变量
> * 共享内存区
>   * 动态库
>   * 共享内存机制
>   * 线程信息
> * 堆（从低地址向高地址增长）非常大，看内存大小
>   * 动态分配内存
> * 数据段
>   * 全局变量+静态变量
> * 代码段（只读）
>   * 二进制代码
>   * 字符串字面值常量

> 如果是大对象，必须在堆上分配
>
> 如果是小对象，并且需要频繁创建和销毁，推荐在栈上分配
>
> 栈上分配内存更高效（esp寄存器做修改）
>
> 堆上分配内存很复杂，可以通过内存池的方式提高效率

### 进程地址空间

> 两个进程同一个变量，地址相同，其实是虚拟地址相同，内容不同其实是被映射（页表）到了不同的物理地址
>
> 这样使得程序之间相互独立，不会因为某个进程崩溃影响其他进程