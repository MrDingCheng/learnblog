# Linux进程控制

### 进程创建

##### fork函数初识

> 在Linux中fork函数时非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程
>
> ```
> #include<unistd.h>
> pid_t fork(void);
> 返回值：子进程中返回0，父进程返回子进程id，出错返回-1
> ```
>
> 进程调用fork，当控制转移到内核中的fork代码后，内核做：
>
> * 分配新的内存块和内核数据结构给子进程
> * 将父进程部分数据结构内容拷贝至子进程
>   * 将父进程的PCB拷贝一份，稍加修改，成为子进程的PCB
>   * 会把父进程的虚拟地址空间拷贝一份，作为子进程的地址空间，写时拷贝=>父子进程共用一份代码，各自有一份数据（一般代码不变的情况），由于大部分的内存空间可能被拷贝，创建进程开销仍然比较高（相对线程），在有些场景下，线程的创建也会被认为开销比较高（相比协程）
> * 添加子进程到系统进程列表当中
> * fork返回会在父子进程中分别返回
>   * 父进程中返回子进程的pid
>   * 子进程返回0
>   * 在fork后面继续往下执行
>
> **fork后的程序运行结果先保存在缓冲区中（内存的一部分），下次fork时如果没有刷新缓冲区（fflush），会把缓冲区的内容也拷贝到子进程中**
>
> **父子进程执行顺序没有先后关系，全靠调度器来实现**
>
> ```
> #include<stdio.h>
> #include<unistd.h>
> 
> inf main(){
>     for(int i=0; i<2;++i)
> }
> ```
>
> fork失败返回-1
>
> * 内存不够
> * 进程太多

### 进程终止

##### 进程退出场景

> * 代码运行完毕，结果正确
> * 代码运行完毕，结果不正确
> * 代码异常终止

##### 代码常见退出方法

正常终止（可以通过echo $?查看进程退出码）：

$?是bash中的一个特殊变量，这个变量表示上个命令对应的进程的退出码

> * main函数返回，返回值叫做进程的退出码，通过这个退出码表示运行结果是否正确
>   * 退出码为0表示结果正确
>   * 退出码非0表示结果不正确
> * 调用exit进程退出（标准库函数），本质上也是调\_eixt，除此之外exit比\_exit多出来的功能
>   * exit关闭流并刷新缓冲区
>   * exit还多调用了结束函数atexit（函数指针）
> * _exit进程退出（系统调用）

异常终止

> 内存访问越界

异常退出：

> ctrl+c,信号终止

return退出

> return n等同于执行exit(n)，因为调用main的运行时函数会将main的返回值当作exit的参数

### 进程等待

##### 进程等待必要性

> * 僵尸进程就是由于子进程未将退出状态返回给父进程造成的

### 进程等待的方法

##### wait方法

> ```
> #include<sys/type.h>
> #include<sys/wait.h>
> //阻塞式的函数，等待子进程结束才返回
> pid_t wait(int* status);
> 
> 返回值：
> 	成功返回被等待进程pid，失败返回-1
> 参数：
> 	输出型参数，获取子进程退出状态，不关心则可以设置成NULL
> ```
>

##### wait的注意事项：

> * wait的 调用次数必须和子进程的个数一致
>   * wait的调用次数比较少，导致僵尸进程
>   * wait的调用次数比较多，多出来的wait就会调用出错，返回-1
> * 如果有多个子进程，任何一个子进程结束都会触发wait的返回

##### waitpid方法

> ```
> pid_t waitpid(pit_t pid,int *status,int options);
> 返回值：
> 	当正常返回的时候waitpid返回收集到的子进程的进程ID
> 	如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集，则返回0；
> 	如果调用出错，则返回-1，这时errno会被设置成相应的值以指示错误所在
> 参数
> 	pid：
> 		pid = -1，等待任一个子进程，与wait等效
> 		pid>0,等待其进程ID与pid相等的子进程
> 	status：
> 		WIFEXITED（status）:若为正常终止子进程的状态，则为真。（查看进程是否是正常退出）
> 		WEXITSTATUS（status）：若WIFEXITED非零，提取子进程退出码（查看进程的退出码）
> 	options：
> 	WNOHANG：若pid指定的子进程没有结束，则waitpid（）函数返回0，不予以等待，若正常结束，则返回该子进程的ID
> 	
> ```

### 进程程序替换

##### 替换原理

> * 程序替换不会创建新进程，也不会销毁进程
> * 替换代码和数据（从一个可执行文件中来）
> * 原有的堆和栈中的数据就全都不要了，根据新的代码的执行过程重新构建堆和栈的内容
>
> 类似与双击exe执行一个程序的过程（操作系统的加载器模块）

##### 替换函数

> exec函数族，参数有差异，底层原理完全相同
>
> 使用时最后一个参数必须是NULL，如果不填程序就是未定义行为
>
> 程序替换经常要搭配fork（）使用，因为一旦替换之后。就会把原来进程中的数据和代码替换，无法执行之后的代码
>
> l=>list变长参数列表
>
> v=>vector=>数组
>
> p表示PATH，表示从PATH的目录中自动查找
>
> e表示用户进行程序替换的时候手动指定环境变量
>
> int execl(const chat*path, const char *arg, ...)
>
> int execlp(const char *file, const char *arg, ...)
>
> int execle(const char *path, const char *arg, ...，const char *env[])
>
> //env[]数组必须以NULL结尾
>
> int execv(const char *path, char *const argv[]);
>
> //argv[]必须以NULL结尾
>
> int execvp(const char *file, char *const argv[]);
>
> int execve(const char *file, char *const argv[], char *const envp[]);
>
> //envp[]数组必须以NULL结尾

##### 函数解释

> * 调用成功则加载新的程序从启动代码开始执行，不在返回
> * 调用出错则返回-1

myshell的改进点：

1.自动获取用户名，主机名，当前路径

2.需要支持cd命令（cd修改的是子进程的路径，对付进程没影响）

​	需要让父进程直接支持cd（而不是创建子进程/程序替换）

​	内建命令

3.支持定义别名（键值对）

std::map

4.支持管道

5.支持重定向