### gcc基本用法

> * -g编译的时候保留调试信息
> * -o1 o2 o3 o4从右到左占内存越小，优化级别越高
> * 程序的实际执行顺序和原始的执行顺序差别越大，必须要关闭优化才能进行调试
> * gcc a.c -g -o a进入调试，如果不写-o默认为-o2
> * gdb a 进入调试
> * gdb attach 进程ID 调试正在运行的进程
>   * bt 查看调栈

### Linux调试器-gdb使用

> 要使用gdb调试，必须在源代码生成二进制程序的时候，加上-g选项

##### 调试命令

> * break/b：在某一行设置断点
> * print/p：打印表达式的值，通过表达式可以修改变量的值或者调用函数
> * continue/c：从当前位置开始连续而非单步执行程序
> * next/n：单步执行（逐过程）
> * step/s：单步执行（逐语句）
> * backtrace/bt：查看函数的调用栈帧
> * frame /f：切换到某个指定栈帧，程序没有回退
> * quit/q：推出gdb
> * info break/b：查看断点信息

##### 调试一个问题的步骤和思路

> 1.确认是不是bug：唯一依据产品需求
>
> 2.定位问题：找到哪行代码引起的bug，通过二分查找
>
> 3.分析问题的原因（幸福感）
>
> 4.提出方案并修改问题
>
> 5.测试（回归测试，防止代码的修改引入新问题，由于回归测试成本比较高，往往以自动化测试为主）

##### gdb工作中用法

> 1.使用gdb调试coredump文件
>
>  coredump就是程序出错的瞬间记录的遗言核心转储文件
>
> ulimit -a设置coredump文件相关
>
> 事后调试
>
> 2.使用gdb attach(附加)上一个程序
>
> TODO（进程相关的内容之后）
>
> cgdb方便一丢丢

##### 工程管理工具：解决大型项目中的模块之间的依赖问题

makefile：这是一个40年前的技术，当前在实际工作中几乎不会手写makefile，但是又必须学习它，当前的现代C/C++工程管理都必须通过工程文件生成makefile文件

三个核心要素：

> 目标
>
> 依赖
>
> 命令
>
> 目标（\$@)：依赖(\$^）
>
> ​    	命令

make命令的执行过程

> 1.现在当前目录中查找Makefile文件
>
> 2.找到要生成的文件（决定是否要真的生成）
>
> 3.检查依赖的文件是否都存在
>
> 4.执行生成动作的命令

一个Makefile中可以存在多个目标，有的目标并不是为了生成文件，而仅仅是为了执行一些额定的动作最典型的就是clean方式（清空之前生成的目标）

make指令后面带上参数（要去生成的目标）

如果Makefile中包含了多个目标，默认调用第一个

clean这样的目标，只是为了执行一个动作，如果此时在目录中碰巧有一个叫clean的文件，就会影响到动作的执行。可以使用.PHONY把clean声明称“伪目标”

CMake：开源世界中广泛使用的构建工具

Blaze(火焰刀)：比较重量级的构建工具

vim打开文件的同时会创建一个swap文件

test.c=>test

如果test.c没用发生变化，就不需要重新生成test

如果test.c已经被修改，那就需要重新生成test

增量编译<=>全量编译

##### 缓冲区刷新：

##### 行缓冲

> * 缓冲区满了
> * 遇到\n会写到显示器，如果是吧数据写到文件就不能刷新缓冲区
> * 程序结束可能会
> * fflush(stdout)

vim 批量注释代码：

> 1.ctrl + v 进入可视化模式
>
> 2.拖动光标选中要注释的列
>
> 3.按I插入
>
> 3.按esc

vim批量取消注释：

> 1.ctrl+v进入可视化模式
>
> 2.拖动光标选中要去注释的列
>
> 按x